<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on l0g - blog</title><link>http://localhost:1313/post/</link><description>Recent content in Posts on l0g - blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Best Time to Buy and Sell Stock</title><link>http://localhost:1313/post/2014-12-4-best-time-to-buy-and-sell-stock-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-4-best-time-to-buy-and-sell-stock-/</guid><description>Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. https://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/ ####这一题容易出错的地方是这样求解，</description></item><item><title>Binary Tree Preorder Traversal</title><link>http://localhost:1313/post/2014-12-11-binary-tree-preorder-traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-11-binary-tree-preorder-traversal/</guid><description>Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values. For example: Given binary tree {1,#,2,3}, 1 \ 2 / 3 return [1,2,3]. Note: Recursive solution is trivial, could you do it iteratively? https://oj.leetcode.com/problems/binary-tree-preorder-traversal/ ####先来个递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode *root)</description></item><item><title>Construct Binary Tree from Preorder and Inorder Traversal</title><link>http://localhost:1313/post/2014-12-4-construct-binary-tree-from-preorder-and-inorder-traversal-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-4-construct-binary-tree-from-preorder-and-inorder-traversal-/</guid><description>Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree https://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ ####我提交下面代码后，提示 Memory Limit Exceeded 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 TreeNode *buildTree(vector&amp;lt;int&amp;gt; &amp;amp;preorder, vector&amp;lt;int&amp;gt; &amp;amp;inorder) { if (preorder.size() == 0) { return</description></item><item><title>Count and Say</title><link>http://localhost:1313/post/2015-03-03-count-and-say/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-03-03-count-and-say/</guid><description>The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, &amp;hellip;
1 is read off as &amp;ldquo;one 1&amp;rdquo; or 11.
11 is read off as &amp;ldquo;two 1s&amp;rdquo; or 21.
21 is read off as &amp;ldquo;one 2, then one 1&amp;rdquo; or 1211.
Given an integer n, generate the nth sequence.
Note: The sequence of integers will be represented as a string. Given a roman numeral, convert it to an integer.</description></item><item><title>Length of Last Word</title><link>http://localhost:1313/post/2014-12-15-length-of-last-word/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-15-length-of-last-word/</guid><description>Given a string s consists of upper/lower-case alphabets and empty space characters ' &amp;lsquo;, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. For example, Given s = &amp;ldquo;Hello World&amp;rdquo;, return 5. https://oj.leetcode.com/problems/length-of-last-word/ ####注意把尾部的空格忽略</description></item><item><title>Maximum Depth of Binary Tree</title><link>http://localhost:1313/post/2014-12-12-maximum-depth-of-binary-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-12-maximum-depth-of-binary-tree/</guid><description>Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
https://oj.leetcode.com/problems/maximum-depth-of-binary-tree/
1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxDepth(TreeNode *root) { if(!root) { return 0; } int left=maxDepth(root-&amp;gt;left); int right=maxDepth(root-&amp;gt;right); return left&amp;lt;right?(right+1):(left+1); } };</description></item><item><title>Maximum Subarray</title><link>http://localhost:1313/post/2014-12-11-maximum-subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-11-maximum-subarray/</guid><description>Find the contiguous subarray within an array (containing at least one number) which has the largest sum. For example, given the array [−2,1,−3,4,−1,2,1,−5,4], the contiguous subarray [4,−1,2,1] has the largest sum = 6. More practice: If you have</description></item><item><title>Merge Sorted Array</title><link>http://localhost:1313/post/2014-11-21-merge-sorted-array-/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-11-21-merge-sorted-array-/</guid><description>Given two sorted integer arrays A and B, merge B into A as one sorted array.
Note: You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.
https://oj.leetcode.com/problems/merge-sorted-array/
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: void merge(int A[], int m, int B[], int n) { int i=0,j=0; int *C=new int[m+n]; while(i&amp;lt;m&amp;amp;&amp;amp;j&amp;lt;n) { if(A[i]&amp;lt;B[j]) { C[i+j]=A[i]; i++; } else { C[i+j]=B[j]; j++; } } while(i&amp;lt;m) { C[i+j]=A[i]; i++; } while(j&amp;lt;n) { C[i+j]=B[j]; j++; } for(i=0;i&amp;lt;m+n;i++) { A[i]=C[i]; } } };</description></item><item><title>Minimum Depth of Binary Tree</title><link>http://localhost:1313/post/2014-12-09-minimum-depth-of-binary-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-09-minimum-depth-of-binary-tree/</guid><description>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/ ####注意当左右子树有一个位空时，此时根不是叶子节点，所以不能简单返回左右子</description></item><item><title>OpenGL基础</title><link>http://localhost:1313/post/2014-11-16-opengl%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-11-16-opengl%E5%9F%BA%E7%A1%80/</guid><description>在刚开始学习图形编程的时候它是一项令人生畏的任务。渲染管线设计大量的步骤，每一步又处理各种数学运算。stage为下一个stage运行实际的程</description></item><item><title>Palindrome Number</title><link>http://localhost:1313/post/2014-12-8-palindrome-number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-8-palindrome-number/</guid><description>Determine whether an integer is a palindrome. Do this without extra space. Some hints: Could negative integers be palindromes? (ie, -1) If you are thinking of converting the integer to string, note the restriction of using extra space. You could also try reversing an integer. However, if you have solved the problem &amp;ldquo;Reverse Integer&amp;rdquo;, you know that the reversed integer might overflow. How would you handle such case? There is</description></item><item><title>Path Sum</title><link>http://localhost:1313/post/2014-12-5-path-sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-5-path-sum/</guid><description>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description></item><item><title>Path Sum II</title><link>http://localhost:1313/post/2014-12-11-path-sum-ii/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-11-path-sum-ii/</guid><description>Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;rsquo;s sum equals the given sum. For example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 return [ [5,4,11,2], [5,8,4,5] ] https://oj.leetcode.com/problems/path-sum-ii/ ####将所有路径种和为sum</description></item><item><title>Pow(x,n)</title><link>http://localhost:1313/post/2015-03-04-powxn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-03-04-powxn/</guid><description>Implement pow(x, n).
https://oj.leetcode.com/problems/powx-n/
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: double pow(double x, int n) { if(n==0) { return 1.0; } if(n&amp;lt;0) { if(n==numeric_limits&amp;lt;int&amp;gt;::min()) { return 1.0/(pow(x,numeric_limits&amp;lt;int&amp;gt;::max())*x); } else { return 1.0/pow(x,-n); } } double result=1.0; for(;n&amp;gt;0;x*=x,n&amp;gt;&amp;gt;=1) { if(n&amp;amp;1) { result*=x; } } return result; } };</description></item><item><title>Remove Duplicates from Sorted Array</title><link>http://localhost:1313/post/2014-12-15-remove-duplicates-from-sorted-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-15-remove-duplicates-from-sorted-array/</guid><description>Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. For example, Given input array A = [1,1,2], Your function should return length = 2, and A is now [1,2]. https://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/ ####注意判断n为0</description></item><item><title>Reverse Integer</title><link>http://localhost:1313/post/2014-12-8-reverse-integer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-8-reverse-integer/</guid><description>Reverse digits of an integer. Example1: x = 123, return 321 Example2: x = -123, return -321 https://oj.leetcode.com/problems/reverse-integer/ 这里要注意判断翻转后的值会不会超过int范围。 hints: 1234%10==4 -1234%10==-4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int reverse(int x) { int max=numeric_limits&amp;lt;int&amp;gt;::max(); int min=numeric_limits&amp;lt;int&amp;gt;::min(); int</description></item><item><title>Roman to Integer</title><link>http://localhost:1313/post/2015-03-03-roman-to-integer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-03-03-roman-to-integer/</guid><description>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. https://oj.leetcode.com/problems/roman-to-integer/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48</description></item><item><title>Same Tree</title><link>http://localhost:1313/post/2014-12-8-same-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-8-same-tree/</guid><description>Given two binary trees, write a function to check if they are equal or not. Two binary trees are considered equal if they are structurally identical and the nodes have the same value. https://oj.leetcode.com/problems/same-tree/ 这个比较简单，遍历就行了。 1 2 3 4 5 6 7 8 9 10 11 12 13 bool isSameTree(TreeNode *p,TreeNode *q) { if(p==q) { return true; }</description></item><item><title>Search a 2D Matrix</title><link>http://localhost:1313/post/2014-11-21-search-a-2d-matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-11-21-search-a-2d-matrix/</guid><description>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. For example, Consider the following matrix: 1 2 3 4 5 [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34,</description></item><item><title>Search in Rotated Sorted Array</title><link>http://localhost:1313/post/2014-12-4-search-in-rotated-sorted-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-4-search-in-rotated-sorted-array/</guid><description>Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. https://oj.leetcode.com/problems/search-in-rotated-sorted-array/ ####看到题目的时候</description></item><item><title>Simplify Path</title><link>http://localhost:1313/post/2015-03-04-simplify-path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-03-04-simplify-path/</guid><description>Given an absolute path for a file (Unix-style), simplify it.
For example, path = &amp;ldquo;/home/&amp;rdquo;, =&amp;gt; &amp;ldquo;/home&amp;rdquo; path = &amp;ldquo;/a/./b/../../c/&amp;rdquo;, =&amp;gt; &amp;ldquo;/c&amp;rdquo;
Corner Cases: Did you consider the case where path = &amp;ldquo;/../&amp;rdquo;? In this case, you should return &amp;ldquo;/&amp;rdquo;. Another corner case is the path might contain multiple slashes &amp;lsquo;/&amp;rsquo; together, such as &amp;ldquo;/home//foo/&amp;rdquo;. In this case, you should ignore redundant slashes and return &amp;ldquo;/home/foo&amp;rdquo;.
https://oj.leetcode.com/problems/simplify-path/
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iterator&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;stack&amp;gt;using namespace std; class Solution { public: string simplifyPath(string path) { vector&amp;lt;string&amp;gt; vs=split(path,&amp;#34;/&amp;#34;); vector&amp;lt;string&amp;gt; s; for(auto str:vs) { if(str==&amp;#34;.</description></item><item><title>Two Sum</title><link>http://localhost:1313/post/2014-11-21-two-sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-11-21-two-sum/</guid><description>Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7,</description></item><item><title>Valid Sudoku</title><link>http://localhost:1313/post/2014-12-09-valid-sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-09-valid-sudoku/</guid><description>Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules. The Sudoku board could be partially filled, where empty cells are filled with the character'.'. ![sudoku]({{ site.baseurl }}/images/Valid Sudoku/sudoku.png) A partially filled sudoku which is valid. Note: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated. https://oj.leetcode.com/problems/valid-sudoku/ ####就是判断每一行</description></item><item><title>vim配置</title><link>http://localhost:1313/post/2015-12-27-vim%E9%85%8D%E7%BD%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-12-27-vim%E9%85%8D%E7%BD%AE/</guid><description>vim看起来还比较舒服的配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56</description></item><item><title>不使用乘除法或if while for 求1...n的和</title><link>http://localhost:1313/post/2015-02-09-%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B9%98%E9%99%A4%E6%B3%95%E6%88%96if-while-for-%E6%B1%821...n%E7%9A%84%E5%92%8C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-02-09-%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B9%98%E9%99%A4%E6%B3%95%E6%88%96if-while-for-%E6%B1%821...n%E7%9A%84%E5%92%8C/</guid><description>在知乎上的一道题，记录下来。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &amp;lt;iostream&amp;gt;using namespace std; int sum(int n) { static decltype(&amp;amp;sum) fun[]={[](int){return 0;},sum}; return n+fun[n&amp;gt;0](n-1); } class Sum { public: Sum() { cur++; sum+=cur; } static int</description></item><item><title>判断序列是不是二叉搜索树的后续遍历</title><link>http://localhost:1313/post/2014-12-5-%E5%88%A4%E6%96%AD%E5%BA%8F%E5%88%97%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2014-12-5-%E5%88%A4%E6%96%AD%E5%BA%8F%E5%88%97%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/</guid><description>这一题是暑假面试百度实习的时候没做出来的一道题。 ####二叉搜索树后序遍历的规律是左子树的后续遍历序列都比根小，右子树后序遍历序列都比根大，</description></item><item><title>多线程下的单例模式</title><link>http://localhost:1313/post/2015-02-21-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-02-21-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>多线程下的单例模式。 一个简单的单例: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Singleton { public: static Singleton* getInstance() { if(instance==nullptr) { instance=new Singleton(); } return instance; } private: Singleton(){}; Singleton(const Singleton&amp;amp;); const Singleton&amp;amp; operator=(const Singleton&amp;amp;); static Singleton *instance; }; Singleton* Singleton::instance=nullptr; 但是</description></item><item><title>结构体大小</title><link>http://localhost:1313/post/2015-02-26-%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-02-26-%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F/</guid><description>求结构体大小 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A { int a; short b; int c; char d; }; class B { double a; short b; int c; char d; }; 在32位机器上用gcc编译以上代码，求sizeo</description></item><item><title>通过使用goagent提高git clone速度</title><link>http://localhost:1313/post/2015-02-23-%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8goagent%E6%8F%90%E9%AB%98git-clone%E9%80%9F%E5%BA%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/post/2015-02-23-%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8goagent%E6%8F%90%E9%AB%98git-clone%E9%80%9F%E5%BA%A6/</guid><description>通过使用goagent提高git clone速度 1 2 3 4 5 6 7 vim ~/.gitconfig add: [http] proxy=http://127.0.0.1:8087 sslVerify=false</description></item></channel></rss>