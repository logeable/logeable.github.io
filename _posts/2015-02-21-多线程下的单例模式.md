---
layout: post
title: 多线程下的单例模式
category: [design pattern,singleton]
---

多线程下的单例模式。

<!--break-->

---

一个简单的单例:

```c++

class Singleton
{
public:
	static Singleton* getInstance()
	{
		if(instance==nullptr)
		{
			instance=new Singleton();
		}
		return instance;
	}
private:
	Singleton(){};
	Singleton(const Singleton&);
	const Singleton& operator=(const Singleton&);
	static Singleton *instance;
};
Singleton* Singleton::instance=nullptr;

```

但是这种单例在多线程环境下就会出现问题。
例如运行下面这段程序：

```c++

#include <iostream>
#include <mutex>
#include <thread>
#include <vector>
#include <algorithm>
using namespace std;

class Singleton
{
public:
	static Singleton* getInstance()
	{
		if(instance==nullptr)
		{
			instance=new Singleton();
		}
		return instance;
	}
	int getNum()
	{
		return num;
	}
private:
	Singleton():num{rand()}
	{
	}
	Singleton(const Singleton&);
	const Singleton& operator=(const Singleton&);
	int num;
	static Singleton *instance;
};
Singleton* Singleton::instance=nullptr;

mutex mtx;
void fun()
{
	int n=Singleton::getInstance()->getNum();
	mtx.lock();
	cout<<n<<endl;
	mtx.unlock();
}
int main(int argc,char *argv[])
{
	srand(time(nullptr));

	vector<thread> vt;
	for(int i=0;i<10;i++)
	{
		vt.push_back(thread(fun));
	}
	for_each(vt.begin(),vt.end(),[](decltype(vt)::value_type& t){t.join();});
	return 0;
}

```

```
logeable@logeable-Aspire-V5-472G:~/workstation/c$ g++ -std=c++11 -pthread test.cpp 
logeable@logeable-Aspire-V5-472G:~/workstation/c$ ./a.out 
1245598312
1130573702
462528514
462528514
462528514
462528514
462528514
462528514
462528514
462528514
```

造成这种问题的原因是线程的执行顺序可能像下面一样.

```

线程1                           线程2          			
static Singleton* getInstance()			
							    static Singleton* getInstance()			
if(instance==nullptr)                                       
							    if(instance==nullptr)          			
instance=new Singleton();                                   
return instance;                                            
							    instance=new Singleton();      			
							    return instance;               			

```

为了消除这种问题可以使用锁.

```c++

class Singleton
{
public:
	static Singleton* getInstance()
	{
		m.lock();
		if(instance==nullptr)
		{
			instance=new Singleton();
		}
		m.unlock();
		return instance;
	}
	int getNum()
	{
		return num;
	}
private:
	Singleton():num{rand()}
	{
	}
	Singleton(const Singleton&);
	const Singleton& operator=(const Singleton&);
	int num;
	static mutex m;
	static Singleton *instance;
};
Singleton* Singleton::instance=nullptr;
mutex Singleton::m;

```

这样就正常的。

```
logeable@logeable-Aspire-V5-472G:~/workstation/c$ g++ -std=c++11 -pthread test.cpp 
logeable@logeable-Aspire-V5-472G:~/workstation/c$ ./a.out 
1932261911
1932261911
1932261911
1932261911
1932261911
1932261911
1932261911
1932261911
1932261911
1932261911
```

但是问题又来了，只有第一次调用getInstance()才需要同步，而上面代码却每次都加锁解锁，对性能会有影响。
可以使用下面几种方法解决：

```c++

class Singleton
{
public:
	static Singleton* getInstance()
	{
		return instance;
	}
	int getNum()
	{
		return num;
	}
private:
	Singleton():num{rand()}
	{
	}
	Singleton(const Singleton&);
	const Singleton& operator=(const Singleton&);
	int num;
	static Singleton *instance;
};
Singleton* Singleton::instance=new Singleton();

```

这种做法的问题是就算不调用getInstance()都会初始化instance静态变量。如果初始化是个比较繁重的任务，可能会对性能有影响。

另一种做法是**double-checked locking**,线检查是否创建示例，如果没有才同步。

```c++

class Singleton
{
public:
	static Singleton* getInstance()
	{
		if(instance==nullptr)
		{
			m.lock();
			if(instance==nullptr)
			{
				instance=new Singleton();
			}
			m.unlock();
		}
		return instance;
	}
	int getNum()
	{
		return num;
	}
private:
	Singleton():num{rand()}
	{
	}
	Singleton(const Singleton&);
	const Singleton& operator=(const Singleton&);
	int num;
	static mutex m;
	static Singleton *instance;
};
Singleton* Singleton::instance=nullptr;
mutex Singleton::m;

```
