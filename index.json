[{"content":"vim 看起来还比较舒服的配置\n set sw=4set sts=4set ts=4set etset smarttabset autoindentset cindentset smartindentset nu\u0026#34; set smsyntax onset culset rulerset showcmdset scrolloff=3\u0026#34; set statusline=%F%m%r%h%w\\ [FORMAT=%{\u0026amp;ff}]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %{strftime(\\\u0026#34;%d/%m/%y\\ -\\ %H:%M\\\u0026#34;)}set laststatus=2set wildmenuset mousemodel=popupset shortmess=alIset history=1000set hlsearchset incsearchset t_Co=256\u0026#34; ==================== vundle configuration ====================set nocompatible \u0026#34; be iMproved, requiredfiletype off \u0026#34; required\u0026#34; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()\u0026#34; alternatively, pass a path where Vundle should install plugins\u0026#34;call vundle#begin(\u0026#39;~/some/path/here\u0026#39;)\u0026#34; let Vundle manage Vundle, requiredPlugin \u0026#39;VundleVim/Vundle.vim\u0026#39;\u0026#34; Keep Plugin commands between vundle#begin/end.\u0026#34; PluginsPlugin \u0026#39;tpope/vim-fugitive\u0026#39;Plugin \u0026#39;tpope/vim-commentary\u0026#39;Plugin \u0026#39;L9\u0026#39;Plugin \u0026#39;bling/vim-airline\u0026#39;Plugin \u0026#39;flazz/vim-colorschemes\u0026#39;Plugin \u0026#39;Valloric/YouCompleteMe\u0026#39;\u0026#34; All of your Plugins must be added before the following linecall vundle#end() \u0026#34; requiredfiletype plugin indent on \u0026#34; required\u0026#34; To ignore plugin indent changes, instead use:\u0026#34;filetype plugin on\u0026#34;\u0026#34; Brief help\u0026#34; :PluginList - lists configured plugins\u0026#34; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate\u0026#34; :PluginSearch foo - searches for foo; append `!` to refresh local cache\u0026#34; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal\u0026#34;\u0026#34; see :h vundle for more details or wiki for FAQ\u0026#34; Put your non-Plugin stuff after this linecolor molokai \u0026#34; 如果放到前面就找不到相应的颜色文件\u0026#34; ==================== airline ====================let g:airline_theme=\u0026#34;luna\u0026#34;","permalink":"http://logeable.github.io/posts/vim%E9%85%8D%E7%BD%AE/","summary":"vim 看起来还比较舒服的配置\n set sw=4set sts=4set ts=4set etset smarttabset autoindentset cindentset smartindentset nu\u0026#34; set smsyntax onset culset rulerset showcmdset scrolloff=3\u0026#34; set statusline=%F%m%r%h%w\\ [FORMAT=%{\u0026amp;ff}]\\ [TYPE=%Y]\\ [POS=%l,%v][%p%%]\\ %{strftime(\\\u0026#34;%d/%m/%y\\ -\\ %H:%M\\\u0026#34;)}set laststatus=2set wildmenuset mousemodel=popupset shortmess=alIset history=1000set hlsearchset incsearchset t_Co=256\u0026#34; ==================== vundle configuration ====================set nocompatible \u0026#34; be iMproved, requiredfiletype off \u0026#34; required\u0026#34; set the runtime path to include Vundle and initializeset rtp+=~/.vim/bundle/Vundle.vimcall vundle#begin()\u0026#34; alternatively, pass a path where Vundle should install plugins\u0026#34;call vundle#begin(\u0026#39;~/some/path/here\u0026#39;)\u0026#34; let Vundle manage Vundle, requiredPlugin \u0026#39;VundleVim/Vundle.","title":"vim配置"},{"content":"Given an absolute path for a file (Unix-style), simplify it.\nFor example, path = \u0026ldquo;/home/\u0026rdquo;, =\u0026gt; \u0026ldquo;/home\u0026rdquo; path = \u0026ldquo;/a/./b/../../c/\u0026rdquo;, =\u0026gt; \u0026ldquo;/c\u0026rdquo;\nCorner Cases: Did you consider the case where path = \u0026ldquo;/../\u0026rdquo;? In this case, you should return \u0026ldquo;/\u0026rdquo;. Another corner case is the path might contain multiple slashes \u0026lsquo;/\u0026rsquo; together, such as \u0026ldquo;/home//foo/\u0026rdquo;. In this case, you should ignore redundant slashes and return \u0026ldquo;/home/foo\u0026rdquo;.\nhttps://oj.leetcode.com/problems/simplify-path/\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;iterator\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;stack\u0026gt;using namespace std;  class Solution { public: \tstring simplifyPath(string path) \t{ \tvector\u0026lt;string\u0026gt; vs=split(path,\u0026#34;/\u0026#34;); \tvector\u0026lt;string\u0026gt; s; \tfor(auto str:vs) \t{ \tif(str==\u0026#34;.\u0026#34;) \t{ \tcontinue; \t} \telse if(str==\u0026#34;..\u0026#34;) \t{ \tif(s.empty()) \t{ \tcontinue; \t} \ts.pop_back(); \t} \telse \t{ \ts.push_back(str); \t} \t} \tostringstream oss; \tfor(auto str:s) \t{ \toss\u0026lt;\u0026lt;\u0026#34;/\u0026#34;\u0026lt;\u0026lt;str; \t} \tif(s.empty()) \t{ \toss\u0026lt;\u0026lt;\u0026#34;/\u0026#34;; \t} \treturn oss.str(); \t}  \tvector\u0026lt;string\u0026gt; split(string str,string delim) \t{ \tvector\u0026lt;string\u0026gt; vs; \tsize_t pos; \twhile((pos=str.find(delim))!=string::npos) \t{ \tauto token=str.substr(0,pos); \tif(!token.empty()) \t{ \tvs.push_back(token); \t} \tstr.erase(0,pos+delim.length()); \t} \tif(!str.empty()) \t{ \tvs.push_back(str); \t} \treturn vs; \t} };  int main(int argc,char*argv[]) { \tSolution s; \tcout\u0026lt;\u0026lt;s.simplifyPath(argv[1])\u0026lt;\u0026lt;endl; \treturn 0; } ","permalink":"http://logeable.github.io/posts/simplify-path/","summary":"Given an absolute path for a file (Unix-style), simplify it.\nFor example, path = \u0026ldquo;/home/\u0026rdquo;, =\u0026gt; \u0026ldquo;/home\u0026rdquo; path = \u0026ldquo;/a/./b/../../c/\u0026rdquo;, =\u0026gt; \u0026ldquo;/c\u0026rdquo;\nCorner Cases: Did you consider the case where path = \u0026ldquo;/../\u0026rdquo;? In this case, you should return \u0026ldquo;/\u0026rdquo;. Another corner case is the path might contain multiple slashes \u0026lsquo;/\u0026rsquo; together, such as \u0026ldquo;/home//foo/\u0026rdquo;. In this case, you should ignore redundant slashes and return \u0026ldquo;/home/foo\u0026rdquo;.\nhttps://oj.leetcode.com/problems/simplify-path/\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;iterator\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;sstream\u0026gt;#include \u0026lt;stack\u0026gt;using namespace std;  class Solution { public: \tstring simplifyPath(string path) \t{ \tvector\u0026lt;string\u0026gt; vs=split(path,\u0026#34;/\u0026#34;); \tvector\u0026lt;string\u0026gt; s; \tfor(auto str:vs) \t{ \tif(str==\u0026#34;.","title":"Simplify Path"},{"content":"Implement pow(x, n).\nhttps://oj.leetcode.com/problems/powx-n/\n  class Solution { public:  double pow(double x, int n) {  if(n==0)  {  return 1.0;  }  if(n\u0026lt;0)  {  if(n==numeric_limits\u0026lt;int\u0026gt;::min())  {  return 1.0/(pow(x,numeric_limits\u0026lt;int\u0026gt;::max())*x);  }  else  {  return 1.0/pow(x,-n);  }  }  double result=1.0;  for(;n\u0026gt;0;x*=x,n\u0026gt;\u0026gt;=1)  {  if(n\u0026amp;1)  {  result*=x;  }  }  return result;  } }; ","permalink":"http://logeable.github.io/posts/powxn/","summary":"Implement pow(x, n).\nhttps://oj.leetcode.com/problems/powx-n/\n  class Solution { public:  double pow(double x, int n) {  if(n==0)  {  return 1.0;  }  if(n\u0026lt;0)  {  if(n==numeric_limits\u0026lt;int\u0026gt;::min())  {  return 1.0/(pow(x,numeric_limits\u0026lt;int\u0026gt;::max())*x);  }  else  {  return 1.0/pow(x,-n);  }  }  double result=1.0;  for(;n\u0026gt;0;x*=x,n\u0026gt;\u0026gt;=1)  {  if(n\u0026amp;1)  {  result*=x;  }  }  return result;  } }; ","title":"Pow(x,n)"},{"content":"Given a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999.\nhttps://oj.leetcode.com/problems/roman-to-integer/\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;using namespace std;  class Solution { public: \tSolution() \t{ \tmci[\u0026#39;I\u0026#39;]=1; \tmci[\u0026#39;V\u0026#39;]=5; \tmci[\u0026#39;X\u0026#39;]=10; \tmci[\u0026#39;L\u0026#39;]=50; \tmci[\u0026#39;C\u0026#39;]=100; \tmci[\u0026#39;D\u0026#39;]=500; \tmci[\u0026#39;M\u0026#39;]=1000; \t}  int romanToInt(string s) \t{ \tint num=0; \tfor(size_t i=0;i\u0026lt;s.length();i++) \t{ \tif(i\u0026gt;0) \t{ \tif(mci[s[i-1]]\u0026lt;mci[s[i]]) \t{ \tnum=num+mci[s[i]]-2*mci[s[i-1]]; \t} \telse \t{ \tnum+=mci[s[i]]; \t} \t} \telse \t{ \tnum+=mci[s[i]]; \t} \t} \treturn num; \t} private: \tmap\u0026lt;char,int\u0026gt; mci; };  int main(int argc,char*argv[]) { \tSolution s; \tcout\u0026lt;\u0026lt;s.romanToInt(\u0026#34;DCXXI\u0026#34;)\u0026lt;\u0026lt;endl; \treturn 0; } http://zh.wikipedia.org/wiki/罗马数字\n","permalink":"http://logeable.github.io/posts/roman-to-integer/","summary":"Given a roman numeral, convert it to an integer.\nInput is guaranteed to be within the range from 1 to 3999.\nhttps://oj.leetcode.com/problems/roman-to-integer/\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;map\u0026gt;using namespace std;  class Solution { public: \tSolution() \t{ \tmci[\u0026#39;I\u0026#39;]=1; \tmci[\u0026#39;V\u0026#39;]=5; \tmci[\u0026#39;X\u0026#39;]=10; \tmci[\u0026#39;L\u0026#39;]=50; \tmci[\u0026#39;C\u0026#39;]=100; \tmci[\u0026#39;D\u0026#39;]=500; \tmci[\u0026#39;M\u0026#39;]=1000; \t}  int romanToInt(string s) \t{ \tint num=0; \tfor(size_t i=0;i\u0026lt;s.length();i++) \t{ \tif(i\u0026gt;0) \t{ \tif(mci[s[i-1]]\u0026lt;mci[s[i]]) \t{ \tnum=num+mci[s[i]]-2*mci[s[i-1]]; \t} \telse \t{ \tnum+=mci[s[i]]; \t} \t} \telse \t{ \tnum+=mci[s[i]]; \t} \t} \treturn num; \t} private: \tmap\u0026lt;char,int\u0026gt; mci; };  int main(int argc,char*argv[]) { \tSolution s; \tcout\u0026lt;\u0026lt;s.","title":"Roman to Integer"},{"content":"The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, \u0026hellip;\n1 is read off as \u0026ldquo;one 1\u0026rdquo; or 11.\n11 is read off as \u0026ldquo;two 1s\u0026rdquo; or 21.\n21 is read off as \u0026ldquo;one 2, then one 1\u0026rdquo; or 1211.\nGiven an integer n, generate the nth sequence.\nNote: The sequence of integers will be represented as a string. Given a roman numeral, convert it to an integer.\nhttps://oj.leetcode.com/problems/count-and-say/\n  #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;sstream\u0026gt;using namespace std;  class Solution { public: \tstring countAndSay(int n) \t{ \tstring str{\u0026#34;1\u0026#34;}; \tif(n==1) \t{ \treturn str; \t} \tfor(int i=1;i\u0026lt;n;i++) \t{ \tstr=generate(str);  \t} \treturn str; \t} \tstring generate(string str) \t{ \tostringstream oss; \tif(str.length()==1) \t{ \toss\u0026lt;\u0026lt;1\u0026lt;\u0026lt;str[0]; \treturn oss.str(); \t} \tint len=1; \tfor(size_t i=1;i\u0026lt;str.length();i++) \t{ \tif(str[i]!=str[i-1]) \t{ \toss\u0026lt;\u0026lt;len\u0026lt;\u0026lt;str[i-1]; \tlen=1; \tif(i==str.length()-1) \t{ \toss\u0026lt;\u0026lt;1\u0026lt;\u0026lt;str[i]; \t} \t} \telse \t{ \tlen++; \tif(i==str.length()-1) \t{ \toss\u0026lt;\u0026lt;len\u0026lt;\u0026lt;str[i]; \t} \t} \t} \treturn oss.str(); \t} };  int main(int argc,char*argv[]) { \tcout\u0026lt;\u0026lt;Solution().countAndSay(6)\u0026lt;\u0026lt;endl; \treturn 0; } ","permalink":"http://logeable.github.io/posts/count-and-say/","summary":"The count-and-say sequence is the sequence of integers beginning as follows: 1, 11, 21, 1211, 111221, \u0026hellip;\n1 is read off as \u0026ldquo;one 1\u0026rdquo; or 11.\n11 is read off as \u0026ldquo;two 1s\u0026rdquo; or 21.\n21 is read off as \u0026ldquo;one 2, then one 1\u0026rdquo; or 1211.\nGiven an integer n, generate the nth sequence.\nNote: The sequence of integers will be represented as a string. Given a roman numeral, convert it to an integer.","title":"Count and Say"},{"content":"求结构体大小\n class A { int a; short b; int c; char d; }; class B { double a; short b; int c; char d; }; 在32位机器上用gcc编译以上代码，求sizeof(A),sizeof(B)分别是多少。 根据以下条件进行计算： 1、 结构体的大小等于结构体内最大成员大小的整数倍 2、 结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍，比如说 double 型成员相对于结构体的首地址的地址偏移量应该是 8 的倍数。 3、 为了满足规则 1 和 2 编译器会在结构体成员之后进行字节填充！\nA 中，a 占 4 个字节，b 本应占 2 个字节，但由于 c 占 4 个字节，为了满足条件 2，b 多占用 2 个字节，为了满足条件 1，d 占用 4 个字节，一共 16 个字节。 B 中，a 占 8 个字节，b 占 2 个字节，但由于 c 占 4 个字节，为了满足条件 2，b 多占用 2 个字节， 即 abc 共占用 8+4+4=16 个字节， 为了满足条件 1，d 将占用 8 个字节，一共 24 个字节。\n","permalink":"http://logeable.github.io/posts/%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%A7%E5%B0%8F/","summary":"求结构体大小\n class A { int a; short b; int c; char d; }; class B { double a; short b; int c; char d; }; 在32位机器上用gcc编译以上代码，求sizeof(A),sizeof(B)分别是多少。 根据以下条件进行计算： 1、 结构体的大小等于结构体内最大成员大小的整数倍 2、 结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍，比如说 double 型成员相对于结构体的首地址的地址偏移量应该是 8 的倍数。 3、 为了满足规则 1 和 2 编译器会在结构体成员之后进行字节填充！\nA 中，a 占 4 个字节，b 本应占 2 个字节，但由于 c 占 4 个字节，为了满足条件 2，b 多占用 2 个字节，为了满足条件 1，d 占用 4 个字节，一共 16 个字节。 B 中，a 占 8 个字节，b 占 2 个字节，但由于 c 占 4 个字节，为了满足条件 2，b 多占用 2 个字节， 即 abc 共占用 8+4+4=16 个字节， 为了满足条件 1，d 将占用 8 个字节，一共 24 个字节。","title":"结构体大小"},{"content":"通过使用 goagent 提高 git clone 速度\n  vim ~/.gitconfig add: [http] proxy=http://127.0.0.1:8087 sslVerify=false ","permalink":"http://logeable.github.io/posts/%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8goagent%E6%8F%90%E9%AB%98git-clone%E9%80%9F%E5%BA%A6/","summary":"通过使用 goagent 提高 git clone 速度\n  vim ~/.gitconfig add: [http] proxy=http://127.0.0.1:8087 sslVerify=false ","title":"通过使用goagent提高git clone速度"},{"content":"多线程下的单例模式。\n 一个简单的单例:\n class Singleton { public: \tstatic Singleton* getInstance() \t{ \tif(instance==nullptr) \t{ \tinstance=new Singleton(); \t} \treturn instance; \t} private: \tSingleton(){}; \tSingleton(const Singleton\u0026amp;); \tconst Singleton\u0026amp; operator=(const Singleton\u0026amp;); \tstatic Singleton *instance; }; Singleton* Singleton::instance=nullptr; 但是这种单例在多线程环境下就会出现问题。 例如运行下面这段程序：\n #include \u0026lt;iostream\u0026gt;#include \u0026lt;mutex\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std;  class Singleton { public: \tstatic Singleton* getInstance() \t{ \tif(instance==nullptr) \t{ \tinstance=new Singleton(); \t} \treturn instance; \t} \tint getNum() \t{ \treturn num; \t} private: \tSingleton():num{rand()} \t{ \t} \tSingleton(const Singleton\u0026amp;); \tconst Singleton\u0026amp; operator=(const Singleton\u0026amp;); \tint num; \tstatic Singleton *instance; }; Singleton* Singleton::instance=nullptr;  mutex mtx; void fun() { \tint n=Singleton::getInstance()-\u0026gt;getNum(); \tmtx.lock(); \tcout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; \tmtx.unlock(); } int main(int argc,char *argv[]) { \tsrand(time(nullptr));  \tvector\u0026lt;thread\u0026gt; vt; \tfor(int i=0;i\u0026lt;10;i++) \t{ \tvt.push_back(thread(fun)); \t} \tfor_each(vt.begin(),vt.end(),[](decltype(vt)::value_type\u0026amp; t){t.join();}); \treturn 0; } logeable@logeable-Aspire-V5-472G:~/workstation/c$ g++ -std=c++11 -pthread test.cpp logeable@logeable-Aspire-V5-472G:~/workstation/c$ ./a.out 1245598312 1130573702 462528514 462528514 462528514 462528514 462528514 462528514 462528514 462528514 造成这种问题的原因是线程的执行顺序可能像下面一样.\n 线程1 线程2 static Singleton* getInstance() static Singleton* getInstance() if(instance==nullptr) if(instance==nullptr) instance=new Singleton(); return instance; instance=new Singleton(); return instance; 为了消除这种问题可以使用锁.\n class Singleton { public: \tstatic Singleton* getInstance() \t{ \tm.lock(); \tif(instance==nullptr) \t{ \tinstance=new Singleton(); \t} \tm.unlock(); \treturn instance; \t} \tint getNum() \t{ \treturn num; \t} private: \tSingleton():num{rand()} \t{ \t} \tSingleton(const Singleton\u0026amp;); \tconst Singleton\u0026amp; operator=(const Singleton\u0026amp;); \tint num; \tstatic mutex m; \tstatic Singleton *instance; }; Singleton* Singleton::instance=nullptr; mutex Singleton::m; 这样就正常的。\nlogeable@logeable-Aspire-V5-472G:~/workstation/c$ g++ -std=c++11 -pthread test.cpp logeable@logeable-Aspire-V5-472G:~/workstation/c$ ./a.out 1932261911 1932261911 1932261911 1932261911 1932261911 1932261911 1932261911 1932261911 1932261911 1932261911 但是问题又来了，只有第一次调用 getInstance()才需要同步，而上面代码却每次都加锁解锁，对性能会有影响。 可以使用下面几种方法解决：\n class Singleton { public: \tstatic Singleton* getInstance() \t{ \treturn instance; \t} \tint getNum() \t{ \treturn num; \t} private: \tSingleton():num{rand()} \t{ \t} \tSingleton(const Singleton\u0026amp;); \tconst Singleton\u0026amp; operator=(const Singleton\u0026amp;); \tint num; \tstatic Singleton *instance; }; Singleton* Singleton::instance=new Singleton(); 这种做法的问题是就算不调用 getInstance()都会初始化 instance 静态变量。如果初始化是个比较繁重的任务，可能会对性能有影响。\n另一种做法是double-checked locking,线检查是否创建示例，如果没有才同步。\n class Singleton { public: \tstatic Singleton* getInstance() \t{ \tif(instance==nullptr) \t{ \tm.lock(); \tif(instance==nullptr) \t{ \tinstance=new Singleton(); \t} \tm.unlock(); \t} \treturn instance; \t} \tint getNum() \t{ \treturn num; \t} private: \tSingleton():num{rand()} \t{ \t} \tSingleton(const Singleton\u0026amp;); \tconst Singleton\u0026amp; operator=(const Singleton\u0026amp;); \tint num; \tstatic mutex m; \tstatic Singleton *instance; }; Singleton* Singleton::instance=nullptr; mutex Singleton::m; ","permalink":"http://logeable.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"多线程下的单例模式。\n 一个简单的单例:\n class Singleton { public: \tstatic Singleton* getInstance() \t{ \tif(instance==nullptr) \t{ \tinstance=new Singleton(); \t} \treturn instance; \t} private: \tSingleton(){}; \tSingleton(const Singleton\u0026amp;); \tconst Singleton\u0026amp; operator=(const Singleton\u0026amp;); \tstatic Singleton *instance; }; Singleton* Singleton::instance=nullptr; 但是这种单例在多线程环境下就会出现问题。 例如运行下面这段程序：\n #include \u0026lt;iostream\u0026gt;#include \u0026lt;mutex\u0026gt;#include \u0026lt;thread\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;algorithm\u0026gt;using namespace std;  class Singleton { public: \tstatic Singleton* getInstance() \t{ \tif(instance==nullptr) \t{ \tinstance=new Singleton(); \t} \treturn instance; \t} \tint getNum() \t{ \treturn num; \t} private: \tSingleton():num{rand()} \t{ \t} \tSingleton(const Singleton\u0026amp;); \tconst Singleton\u0026amp; operator=(const Singleton\u0026amp;); \tint num; \tstatic Singleton *instance; }; Singleton* Singleton::instance=nullptr;  mutex mtx; void fun() { \tint n=Singleton::getInstance()-\u0026gt;getNum(); \tmtx.","title":"多线程下的单例模式"},{"content":"在知乎上的一道题，记录下来。\n #include \u0026lt;iostream\u0026gt;using namespace std;  int sum(int n) { \tstatic decltype(\u0026amp;sum) fun[]={[](int){return 0;},sum}; \treturn n+fun[n\u0026gt;0](n-1); }  class Sum { public: \tSum() \t{ \tcur++; \tsum+=cur; \t} \tstatic int sum; \tstatic int cur; }; int Sum::sum=0; int Sum::cur=0;  int main(int argc,char *argv[]) { \tcout\u0026lt;\u0026lt;sum(10)\u0026lt;\u0026lt;endl; \tSum s[10]; \tcout\u0026lt;\u0026lt;Sum::sum\u0026lt;\u0026lt;endl; \treturn 0; } ","permalink":"http://logeable.github.io/posts/%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B9%98%E9%99%A4%E6%B3%95%E6%88%96if-while-for-%E6%B1%821...n%E7%9A%84%E5%92%8C/","summary":"在知乎上的一道题，记录下来。\n #include \u0026lt;iostream\u0026gt;using namespace std;  int sum(int n) { \tstatic decltype(\u0026amp;sum) fun[]={[](int){return 0;},sum}; \treturn n+fun[n\u0026gt;0](n-1); }  class Sum { public: \tSum() \t{ \tcur++; \tsum+=cur; \t} \tstatic int sum; \tstatic int cur; }; int Sum::sum=0; int Sum::cur=0;  int main(int argc,char *argv[]) { \tcout\u0026lt;\u0026lt;sum(10)\u0026lt;\u0026lt;endl; \tSum s[10]; \tcout\u0026lt;\u0026lt;Sum::sum\u0026lt;\u0026lt;endl; \treturn 0; } ","title":"不使用乘除法或if while for 求1...n的和"},{"content":"Given a string s consists of upper/lower-case alphabets and empty space characters \u0026rsquo; \u0026lsquo;, return the length of last word in the string.\nIf the last word does not exist, return 0.\nNote: A word is defined as a character sequence consists of non-space characters only.\nFor example, Given s = \u0026ldquo;Hello World\u0026rdquo;, return 5.\nhttps://oj.leetcode.com/problems/length-of-last-word/\n ####注意把尾部的空格忽略掉\nclass Solution { public:  int lengthOfLastWord(const char *s) {  int len=0;  int start=strlen(s)-1;  while(s[start]==\u0026#39; \u0026#39;)  {  start--;  }  for(int i=start;i\u0026gt;=0\u0026amp;\u0026amp;s[i]!=\u0026#39; \u0026#39;;i--)  {  len++;  }  return len;  } }; ","permalink":"http://logeable.github.io/posts/length-of-last-word/","summary":"Given a string s consists of upper/lower-case alphabets and empty space characters \u0026rsquo; \u0026lsquo;, return the length of last word in the string.\nIf the last word does not exist, return 0.\nNote: A word is defined as a character sequence consists of non-space characters only.\nFor example, Given s = \u0026ldquo;Hello World\u0026rdquo;, return 5.\nhttps://oj.leetcode.com/problems/length-of-last-word/\n ####注意把尾部的空格忽略掉\nclass Solution { public:  int lengthOfLastWord(const char *s) {  int len=0;  int start=strlen(s)-1;  while(s[start]==\u0026#39; \u0026#39;)  {  start--;  }  for(int i=start;i\u0026gt;=0\u0026amp;\u0026amp;s[i]!","title":"Length of Last Word"},{"content":"Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nFor example, Given input array A = [1,1,2],\nYour function should return length = 2, and A is now [1,2].\nhttps://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/\n ####注意判断 n 为 0\nclass Solution { public:  int removeDuplicates(int A[], int n) {  if(n==0)  {  return n;  }  int index=0;  for(int i=1;i\u0026lt;n;i++)  {  if(A[i]!=A[index])  {  A[++index]=A[i];  }  }  return index+1;  } }; ","permalink":"http://logeable.github.io/posts/remove-duplicates-from-sorted-array/","summary":"Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.\nDo not allocate extra space for another array, you must do this in place with constant memory.\nFor example, Given input array A = [1,1,2],\nYour function should return length = 2, and A is now [1,2].\nhttps://oj.leetcode.com/problems/remove-duplicates-from-sorted-array/\n ####注意判断 n 为 0\nclass Solution { public:  int removeDuplicates(int A[], int n) {  if(n==0)  {  return n;  }  int index=0;  for(int i=1;i\u0026lt;n;i++)  {  if(A[i]!","title":"Remove Duplicates from Sorted Array"},{"content":"Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nhttps://oj.leetcode.com/problems/maximum-depth-of-binary-tree/\n class Solution { public:  int maxDepth(TreeNode *root) {  if(!root)  {  return 0;  }  int left=maxDepth(root-\u0026gt;left);  int right=maxDepth(root-\u0026gt;right);  return left\u0026lt;right?(right+1):(left+1);  } }; ","permalink":"http://logeable.github.io/posts/maximum-depth-of-binary-tree/","summary":"Given a binary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nhttps://oj.leetcode.com/problems/maximum-depth-of-binary-tree/\n class Solution { public:  int maxDepth(TreeNode *root) {  if(!root)  {  return 0;  }  int left=maxDepth(root-\u0026gt;left);  int right=maxDepth(root-\u0026gt;right);  return left\u0026lt;right?(right+1):(left+1);  } }; ","title":"Maximum Depth of Binary Tree"},{"content":"Given a binary tree and a sum, find all root-to-leaf paths where each path\u0026rsquo;s sum equals the given sum.\nFor example: Given the below binary tree and sum = 22,\nreturn\nhttps://oj.leetcode.com/problems/path-sum-ii/\n ####将所有路径种和为 sum 的路径添加到 result 中。\nclass Solution { public:  vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; pathSum(TreeNode *root, int sum)  {  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vvi;  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result;  vector\u0026lt;int\u0026gt; v;  getPaths(root,v,vvi);  for(auto path:vvi)  {  if(accumulate(path.begin(),path.end(),0)==sum)  {  result.push_back(path);  }  }  return result;  }   void getPaths(TreeNode *root,vector\u0026lt;int\u0026gt; v,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;vvi)  {  if(!root)  {  return;  }  if(!root-\u0026gt;left\u0026amp;\u0026amp;!root-\u0026gt;right)  {  v.push_back(root-\u0026gt;val);  vvi.push_back(v);  return;  }  v.push_back(root-\u0026gt;val);  if(root-\u0026gt;left)  {  getPaths(root-\u0026gt;left,v,vvi);  }  if(root-\u0026gt;right)  {  getPaths(root-\u0026gt;right,v,vvi);  }  } }; ","permalink":"http://logeable.github.io/posts/path-sum-ii/","summary":"Given a binary tree and a sum, find all root-to-leaf paths where each path\u0026rsquo;s sum equals the given sum.\nFor example: Given the below binary tree and sum = 22,\nreturn\nhttps://oj.leetcode.com/problems/path-sum-ii/\n ####将所有路径种和为 sum 的路径添加到 result 中。\nclass Solution { public:  vector\u0026lt;vector\u0026lt;int\u0026gt; \u0026gt; pathSum(TreeNode *root, int sum)  {  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vvi;  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result;  vector\u0026lt;int\u0026gt; v;  getPaths(root,v,vvi);  for(auto path:vvi)  {  if(accumulate(path.begin(),path.end(),0)==sum)  {  result.","title":"Path Sum II"},{"content":"Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\nFor example, given the array [−2,1,−3,4,−1,2,1,−5,4], the contiguous subarray [4,−1,2,1] has the largest sum = 6.\nMore practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\nhttps://oj.leetcode.com/problems/maximum-subarray/\n ####最简单的当然是枚举所有子数组，复杂度为 O(n^2),用贪心算法可以实现复杂度为 O(n)。\nclass Solution { public:  int maxSubArray(int A[], int n) {  int max=A[0];  int curMax=A[0];  for(int i=1;i\u0026lt;n;i++)  {  if(curMax\u0026lt;0)  {  curMax=0;  }  curMax+=A[i];  if(curMax\u0026gt;max)  {  max=curMax;  }  }  return max;  } }; ","permalink":"http://logeable.github.io/posts/maximum-subarray/","summary":"Find the contiguous subarray within an array (containing at least one number) which has the largest sum.\nFor example, given the array [−2,1,−3,4,−1,2,1,−5,4], the contiguous subarray [4,−1,2,1] has the largest sum = 6.\nMore practice: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.\nhttps://oj.leetcode.com/problems/maximum-subarray/\n ####最简单的当然是枚举所有子数组，复杂度为 O(n^2),用贪心算法可以实现复杂度为 O(n)。\nclass Solution { public:  int maxSubArray(int A[], int n) {  int max=A[0];  int curMax=A[0];  for(int i=1;i\u0026lt;n;i++)  {  if(curMax\u0026lt;0)  {  curMax=0;  }  curMax+=A[i];  if(curMax\u0026gt;max)  {  max=curMax;  }  }  return max;  } }; ","title":"Maximum Subarray"},{"content":"Given a binary tree, return the preorder traversal of its nodes\u0026rsquo; values.\nFor example: Given binary tree {1,#,2,3},\nreturn [1,2,3].\nNote: Recursive solution is trivial, could you do it iteratively?\nhttps://oj.leetcode.com/problems/binary-tree-preorder-traversal/\n ####先来个递归\nclass Solution { public:  vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) {  vector\u0026lt;int\u0026gt; vi;  preorderTraversal(root,vi);  return vi;  }  void preorderTraversal(TreeNode *root,vector\u0026lt;int\u0026gt; \u0026amp;v)  {  if(!root)  {  return;  }  v.push_back(root-\u0026gt;val);  preorderTraversal(root-\u0026gt;left,v);  preorderTraversal(root-\u0026gt;right,v);  } }; ####再来个非递归\nclass Solution { public:  vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) {  if(!root)  {  return {};  }  stack\u0026lt;TreeNode*\u0026gt; st;  vector\u0026lt;int\u0026gt; vi;  st.push(root);  while(!st.empty())  {  auto tmp=st.top();  vi.push_back(tmp-\u0026gt;val);  st.pop();  if(tmp-\u0026gt;right)  {  st.push(tmp-\u0026gt;right);  }  if(tmp-\u0026gt;left)  {  st.push(tmp-\u0026gt;left);  }  }  return vi;  } }; ","permalink":"http://logeable.github.io/posts/binary-tree-preorder-traversal/","summary":"Given a binary tree, return the preorder traversal of its nodes\u0026rsquo; values.\nFor example: Given binary tree {1,#,2,3},\nreturn [1,2,3].\nNote: Recursive solution is trivial, could you do it iteratively?\nhttps://oj.leetcode.com/problems/binary-tree-preorder-traversal/\n ####先来个递归\nclass Solution { public:  vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode *root) {  vector\u0026lt;int\u0026gt; vi;  preorderTraversal(root,vi);  return vi;  }  void preorderTraversal(TreeNode *root,vector\u0026lt;int\u0026gt; \u0026amp;v)  {  if(!root)  {  return;  }  v.push_back(root-\u0026gt;val);  preorderTraversal(root-\u0026gt;left,v);  preorderTraversal(root-\u0026gt;right,v);  } }; ####再来个非递归","title":"Binary Tree Preorder Traversal"},{"content":"Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\nThe Sudoku board could be partially filled, where empty cells are filled with the character'.'.\n![sudoku]({{ site.baseurl }}/images/Valid Sudoku/sudoku.png)\nA partially filled sudoku which is valid.\nNote: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\nhttps://oj.leetcode.com/problems/valid-sudoku/\n ####就是判断每一行，每一列，每一个九宫格里有没有相同的数，有的话则返回 false,否则返回 true。虽然有点丑陋。。。不过还是 ac 了。\nclass Solution { public:  bool isValid(vector\u0026lt;char\u0026gt; \u0026amp;v)  { \tsort(v.begin(),v.end());  int s=v.size();  auto e=unique(v.begin(),v.end()); \treturn e-v.begin()==s;  }  bool isValidSudoku(vector\u0026lt;vector\u0026lt;char\u0026gt; \u0026gt; \u0026amp;board) {  for(int i=0;i\u0026lt;9;i++)  {  vector\u0026lt;char\u0026gt; v;  for(int j=0;j\u0026lt;9;j++)  {  if(board[i][j]!=\u0026#39;.\u0026#39;)  {  v.push_back(board[i][j]);  }  }  if(!isValid(v))  {  return false;  }  }  for(int i=0;i\u0026lt;9;i++)  {  vector\u0026lt;char\u0026gt; v;  for(int j=0;j\u0026lt;9;j++)  {  if(board[j][i]!=\u0026#39;.\u0026#39;)  {  v.push_back(board[j][i]);  }  }  if(!isValid(v))  {  return false;  }  }  for(int i=0;i\u0026lt;9;i+=3)  {  for(int j=0;j\u0026lt;9;j+=3)  {  vector\u0026lt;char\u0026gt; v;  for(int m=0;m\u0026lt;3;m++)  {  for(int n=0;n\u0026lt;3;n++)  {  if(board[m+i][n+j]!=\u0026#39;.\u0026#39;)  {  v.push_back(board[m+i][n+j]);  }  }  }  if(!isValid(v))  {  return false;  }  }  }  return true;  } }; ","permalink":"http://logeable.github.io/posts/valid-sudoku/","summary":"Determine if a Sudoku is valid, according to: Sudoku Puzzles - The Rules.\nThe Sudoku board could be partially filled, where empty cells are filled with the character'.'.\n![sudoku]({{ site.baseurl }}/images/Valid Sudoku/sudoku.png)\nA partially filled sudoku which is valid.\nNote: A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.\nhttps://oj.leetcode.com/problems/valid-sudoku/\n ####就是判断每一行，每一列，每一个九宫格里有没有相同的数，有的话则返回 false,否则返回 true。虽然有点丑陋。。。不过还是 ac 了。\nclass Solution { public:  bool isValid(vector\u0026lt;char\u0026gt; \u0026amp;v)  { \tsort(v.","title":"Valid Sudoku"},{"content":"Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nhttps://oj.leetcode.com/problems/minimum-depth-of-binary-tree/\n ####注意当左右子树有一个位空时，此时根不是叶子节点，所以不能简单返回左右子树中较小的那个。\nint minDepth(TreeNode *root) { \tif(root==nullptr) \t{ \treturn 0; \t} \tif(root-\u0026gt;left==nullptr\u0026amp;\u0026amp;root-\u0026gt;right==nullptr) \t{ \treturn 1; \t} \tint u,v; \tu=v=numeric_limits\u0026lt;int\u0026gt;::max(); \tif(root-\u0026gt;left) \t{ \tu=minDepth(root-\u0026gt;left); \t} \tif(root-\u0026gt;right) \t{ \tv=minDepth(root-\u0026gt;right); \t} \treturn 1+(u\u0026lt;v?u:v); } ","permalink":"http://logeable.github.io/posts/minimum-depth-of-binary-tree/","summary":"Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nhttps://oj.leetcode.com/problems/minimum-depth-of-binary-tree/\n ####注意当左右子树有一个位空时，此时根不是叶子节点，所以不能简单返回左右子树中较小的那个。\nint minDepth(TreeNode *root) { \tif(root==nullptr) \t{ \treturn 0; \t} \tif(root-\u0026gt;left==nullptr\u0026amp;\u0026amp;root-\u0026gt;right==nullptr) \t{ \treturn 1; \t} \tint u,v; \tu=v=numeric_limits\u0026lt;int\u0026gt;::max(); \tif(root-\u0026gt;left) \t{ \tu=minDepth(root-\u0026gt;left); \t} \tif(root-\u0026gt;right) \t{ \tv=minDepth(root-\u0026gt;right); \t} \treturn 1+(u\u0026lt;v?","title":"Minimum Depth of Binary Tree"},{"content":"Given two binary trees, write a function to check if they are equal or not.\nTwo binary trees are considered equal if they are structurally identical and the nodes have the same value.\nhttps://oj.leetcode.com/problems/same-tree/\n 这个比较简单，遍历就行了。\nbool isSameTree(TreeNode *p,TreeNode *q) { \tif(p==q) \t{ \treturn true; \t} \tif(p==nullptr\u0026amp;\u0026amp;q!=p||q==nullptr\u0026amp;\u0026amp;q!=p) \t{ \treturn false; \t} \treturn p-\u0026gt;val==q-\u0026gt;val\u0026amp;\u0026amp; \tisSameTree(p-\u0026gt;left,q-\u0026gt;left)\u0026amp;\u0026amp;isSameTree(p-\u0026gt;right,q-\u0026gt;right); } ","permalink":"http://logeable.github.io/posts/same-tree/","summary":"Given two binary trees, write a function to check if they are equal or not.\nTwo binary trees are considered equal if they are structurally identical and the nodes have the same value.\nhttps://oj.leetcode.com/problems/same-tree/\n 这个比较简单，遍历就行了。\nbool isSameTree(TreeNode *p,TreeNode *q) { \tif(p==q) \t{ \treturn true; \t} \tif(p==nullptr\u0026amp;\u0026amp;q!=p||q==nullptr\u0026amp;\u0026amp;q!=p) \t{ \treturn false; \t} \treturn p-\u0026gt;val==q-\u0026gt;val\u0026amp;\u0026amp; \tisSameTree(p-\u0026gt;left,q-\u0026gt;left)\u0026amp;\u0026amp;isSameTree(p-\u0026gt;right,q-\u0026gt;right); } ","title":"Same Tree"},{"content":"Reverse digits of an integer.\nExample1: x = 123, return 321 Example2: x = -123, return -321\nhttps://oj.leetcode.com/problems/reverse-integer/\n 这里要注意判断翻转后的值会不会超过 int 范围。\nhints: 1234%10==4 -1234%10==-4\nint reverse(int x) { \tint max=numeric_limits\u0026lt;int\u0026gt;::max(); \tint min=numeric_limits\u0026lt;int\u0026gt;::min();  \tint result=0; \twhile(x!=0) \t{ \tif(result\u0026lt;min/10||result\u0026gt;max/10) \t{ \treturn 0; \t} \tresult=result*10+x%10; \tx/=10; \t} \treturn result; } ","permalink":"http://logeable.github.io/posts/reverse-integer/","summary":"Reverse digits of an integer.\nExample1: x = 123, return 321 Example2: x = -123, return -321\nhttps://oj.leetcode.com/problems/reverse-integer/\n 这里要注意判断翻转后的值会不会超过 int 范围。\nhints: 1234%10==4 -1234%10==-4\nint reverse(int x) { \tint max=numeric_limits\u0026lt;int\u0026gt;::max(); \tint min=numeric_limits\u0026lt;int\u0026gt;::min();  \tint result=0; \twhile(x!=0) \t{ \tif(result\u0026lt;min/10||result\u0026gt;max/10) \t{ \treturn 0; \t} \tresult=result*10+x%10; \tx/=10; \t} \treturn result; } ","title":"Reverse Integer"},{"content":"Determine whether an integer is a palindrome. Do this without extra space.\nSome hints: Could negative integers be palindromes? (ie, -1)\nIf you are thinking of converting the integer to string, note the restriction of using extra space.\nYou could also try reversing an integer. However, if you have solved the problem \u0026ldquo;Reverse Integer\u0026rdquo;, you know that the reversed integer might overflow. How would you handle such case?\nThere is a more generic way of solving this problem.\nhttps://oj.leetcode.com/problems/palindrome-number/\n 要注意负数不会是回文的。 ps:介绍中提到:\nHowever, if you have solved the problem \u0026ldquo;Reverse Integer\u0026rdquo;, you know that the reversed integer might overflow\n但是还是 ac 的。\nint reverse(int x) { \tint max=numeric_limits\u0026lt;int\u0026gt;::max(); \tint min=numeric_limits\u0026lt;int\u0026gt;::min();  \tint result=0; \twhile(x!=0) \t{ \tif(result\u0026lt;min/10||result\u0026gt;max/10) \t{ \treturn 0; \t} \tresult=result*10+x%10; \tx/=10; \t} \treturn result; } bool isPalindrome(int x) { \treturn x\u0026gt;=0\u0026amp;\u0026amp;x==reverse(x); } ","permalink":"http://logeable.github.io/posts/palindrome-number/","summary":"Determine whether an integer is a palindrome. Do this without extra space.\nSome hints: Could negative integers be palindromes? (ie, -1)\nIf you are thinking of converting the integer to string, note the restriction of using extra space.\nYou could also try reversing an integer. However, if you have solved the problem \u0026ldquo;Reverse Integer\u0026rdquo;, you know that the reversed integer might overflow. How would you handle such case?\nThere is a more generic way of solving this problem.","title":"Palindrome Number"},{"content":"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nFor example: Given the below binary tree and sum = 22,\nreturn true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum is 22.\nhttps://oj.leetcode.com/problems/path-sum/\n bool hasPathSum(TreeNode *root,int sum) { \tif(root==nullptr) \t{ \treturn false; \t} \tif(root-\u0026gt;left==nullptr\u0026amp;\u0026amp;root-\u0026gt;right==nullptr) \t{ \treturn sum==root-\u0026gt;val; \t} \tif(root-\u0026gt;left) \t{ \troot-\u0026gt;left-\u0026gt;val+=root-\u0026gt;val; \tif(hasPathSum(root-\u0026gt;left,sum)) \t{ \treturn true; \t} \t} \tif(root-\u0026gt;right) \t{ \troot-\u0026gt;right-\u0026gt;val+=root-\u0026gt;val; \tif(hasPathSum(root-\u0026gt;right,sum)) \t{ \treturn true; \t} \t} \treturn false; } ####不过上面的程序会修改节点的值，只要修改 sum 就能避免。\nbool hasPathSum(TreeNode *root,int sum) { \tif(root==nullptr) \t{ \treturn false; \t} \tif(root-\u0026gt;left==nullptr\u0026amp;\u0026amp;root-\u0026gt;right==nullptr) \t{ \treturn sum==root-\u0026gt;val; \t} \tif(root-\u0026gt;left) \t{ \tif(hasPathSum(root-\u0026gt;left,sum-root-\u0026gt;val))//修改sum \t{ \treturn true; \t} \t} \tif(root-\u0026gt;right) \t{ \tif(hasPathSum(root-\u0026gt;right,sum-root-\u0026gt;val))//修改sum \t{ \treturn true; \t} \t} \treturn false; } ####返回所有路径，判断所有路径中是否有和位 sum 的路径。\nbool hasPathSum(TreeNode *root,int sum) {  vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vvi; \tvector\u0026lt;int\u0026gt; v; \tgetPaths(root,v,vvi); \tfor(auto path:vvi) \t{ \tif(accumulate(path.begin(),path.end(),0)==sum) \t{ \treturn true; \t} \t} \treturn false; } void getPaths(TreeNode *root,vector\u0026lt;int\u0026gt; v,vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;vvi) {  if(!root)  {  return;  }  if(!root-\u0026gt;left\u0026amp;\u0026amp;!root-\u0026gt;right)  {  v.push_back(root-\u0026gt;val);  vvi.push_back(v);  return;  }  v.push_back(root-\u0026gt;val);  if(root-\u0026gt;left)  {  getPaths(root-\u0026gt;left,v,vvi);  }  if(root-\u0026gt;right)  {  getPaths(root-\u0026gt;right,v,vvi);  } } ####进一步可以选非递归的方式\nbool hasPathSum(TreeNode *root,int sum) { \tif(root==nullptr) \t{ \treturn false; \t} \tstack\u0026lt;TreeNode*\u0026gt; st; \tstack\u0026lt;int\u0026gt; si; \tst.push(root); \tsi.push(sum); \twhile(!st.empty()) \t{ \tauto tmp=st.top(); \tauto total=si.top(); \tif(tmp-\u0026gt;left==nullptr\u0026amp;\u0026amp;tmp-\u0026gt;right==nullptr) \t{ \tif(total==tmp-\u0026gt;val) \t{ \treturn true; \t} \t} \tst.pop(); \tsi.pop(); \tif(tmp-\u0026gt;right) \t{ \tsi.push(total-tmp-\u0026gt;val); \tst.push(tmp-\u0026gt;right); \t} \tif(tmp-\u0026gt;left) \t{ \tsi.push(total-tmp-\u0026gt;val); \tst.push(tmp-\u0026gt;left); \t} \t} \treturn false; } ","permalink":"http://logeable.github.io/posts/path-sum/","summary":"Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.\nFor example: Given the below binary tree and sum = 22,\nreturn true, as there exist a root-to-leaf path 5-\u0026gt;4-\u0026gt;11-\u0026gt;2 which sum is 22.\nhttps://oj.leetcode.com/problems/path-sum/\n bool hasPathSum(TreeNode *root,int sum) { \tif(root==nullptr) \t{ \treturn false; \t} \tif(root-\u0026gt;left==nullptr\u0026amp;\u0026amp;root-\u0026gt;right==nullptr) \t{ \treturn sum==root-\u0026gt;val; \t} \tif(root-\u0026gt;left) \t{ \troot-\u0026gt;left-\u0026gt;val+=root-\u0026gt;val; \tif(hasPathSum(root-\u0026gt;left,sum)) \t{ \treturn true; \t} \t} \tif(root-\u0026gt;right) \t{ \troot-\u0026gt;right-\u0026gt;val+=root-\u0026gt;val; \tif(hasPathSum(root-\u0026gt;right,sum)) \t{ \treturn true; \t} \t} \treturn false; } ####不过上面的程序会修改节点的值，只要修改 sum 就能避免。","title":"Path Sum"},{"content":"这一题是暑假面试百度实习的时候没做出来的一道题。\n ####二叉搜索树后序遍历的规律是左子树的后续遍历序列都比根小，右子树后序遍历序列都比根大，形如[左子树 右子树 根]。判断方法就是从左遍历序列，找出第一个比根大的元素，然后从这个元素到根（不包括根）的元素都必须比根大。然后递归的判断左右子序列，当子序列只有一个或没有节点的时候返回真。\nbool judge(vector\u0026lt;int\u0026gt;::iterator first,vector\u0026lt;int\u0026gt;::iterator last) { \tif(first==last||distance(first,last)==1) \t{ \treturn true; \t} \tauto root=last-1; \tvector\u0026lt;int\u0026gt;::iterator pos=first; \tfor(auto iter=first;iter!=root;iter++) \t{ \tif(*iter\u0026gt;*root) \t{ \tpos=iter; \tbreak; \t} \t} \tfor(auto iter=pos;iter!=root;iter++) \t{ \tif(*iter\u0026lt;*root) \t{ \treturn false; \t} \t} \treturn judge(first,pos)\u0026amp;\u0026amp;judge(pos,root); } bool isBinarySearchTreePostOrder(vector\u0026lt;int\u0026gt; vec) { \tjudge(vec.begin(),vec.end()); } ","permalink":"http://logeable.github.io/posts/%E5%88%A4%E6%96%AD%E5%BA%8F%E5%88%97%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/","summary":"这一题是暑假面试百度实习的时候没做出来的一道题。\n ####二叉搜索树后序遍历的规律是左子树的后续遍历序列都比根小，右子树后序遍历序列都比根大，形如[左子树 右子树 根]。判断方法就是从左遍历序列，找出第一个比根大的元素，然后从这个元素到根（不包括根）的元素都必须比根大。然后递归的判断左右子序列，当子序列只有一个或没有节点的时候返回真。\nbool judge(vector\u0026lt;int\u0026gt;::iterator first,vector\u0026lt;int\u0026gt;::iterator last) { \tif(first==last||distance(first,last)==1) \t{ \treturn true; \t} \tauto root=last-1; \tvector\u0026lt;int\u0026gt;::iterator pos=first; \tfor(auto iter=first;iter!=root;iter++) \t{ \tif(*iter\u0026gt;*root) \t{ \tpos=iter; \tbreak; \t} \t} \tfor(auto iter=pos;iter!=root;iter++) \t{ \tif(*iter\u0026lt;*root) \t{ \treturn false; \t} \t} \treturn judge(first,pos)\u0026amp;\u0026amp;judge(pos,root); } bool isBinarySearchTreePostOrder(vector\u0026lt;int\u0026gt; vec) { \tjudge(vec.begin(),vec.end()); } ","title":"判断序列是不是二叉搜索树的后续遍历"},{"content":"Suppose a sorted array is rotated at some pivot unknown to you beforehand.\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\nYou may assume no duplicate exists in the array.\nhttps://oj.leetcode.com/problems/search-in-rotated-sorted-array/\n ####看到题目的时候顺手写了个 O(n)的顺序查找，居然也能通过\nint search(int A[], int n, int target) { \tfor(int i=0;i\u0026lt;n;i++) \t{ \tif(target==A[i]) \t{ \treturn i; \t} \t} \treturn -1; } ####其实还是可以用 O(logn)的二分查找的\nint search(int A[], int n, int target) { \tint l=0,r=n-1; \tint mid; \twhile(l\u0026lt;=r) \t{ \tmid=l+(r-l)/2; \tif(A[mid]==target) \t{ \treturn mid; \t} \tif(A[mid]\u0026gt;=A[l]) \t{ \tif(target\u0026gt;=A[l]\u0026amp;\u0026amp;target\u0026lt;A[mid]) \t{ \tr=mid-1; \t} \telse \t{ \tl=mid+1; \t} \t} \telse \t{ \tif(target\u0026gt;A[mid]\u0026amp;\u0026amp;target\u0026lt;=A[r]) \t{ \tl=mid+1; \t} \telse \t{ \tr=mid-1; \t} \t} \t} \treturn -1; } ","permalink":"http://logeable.github.io/posts/search-in-rotated-sorted-array/","summary":"Suppose a sorted array is rotated at some pivot unknown to you beforehand.\n(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\nYou may assume no duplicate exists in the array.\nhttps://oj.leetcode.com/problems/search-in-rotated-sorted-array/\n ####看到题目的时候顺手写了个 O(n)的顺序查找，居然也能通过\nint search(int A[], int n, int target) { \tfor(int i=0;i\u0026lt;n;i++) \t{ \tif(target==A[i]) \t{ \treturn i; \t} \t} \treturn -1; } ####其实还是可以用 O(logn)的二分查找的","title":"Search in Rotated Sorted Array"},{"content":"Given preorder and inorder traversal of a tree, construct the binary tree.\nNote: You may assume that duplicates do not exist in the tree\nhttps://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\n ####我提交下面代码后，提示 Memory Limit Exceeded\nTreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { \tif (preorder.size() == 0) \t{ \treturn nullptr; \t}  \tauto root = new TreeNode(preorder[0]); \tauto itrPos = find(inorder.begin(), inorder.end(), preorder[0]); \tvector\u0026lt;int\u0026gt; vlin(inorder.begin(),itrPos),vrin(itrPos+1,inorder.end()); \tvector\u0026lt;int\u0026gt; vlpre(preorder.begin() + 1, preorder.begin() + 1 + vlin.size()), vrpre(preorder.begin() + 1 + vlin.size(),preorder.end()); \troot-\u0026gt;left = buildTree(vlpre,vlin); \troot-\u0026gt;right = buildTree(vrpre,vrin); \treturn root; } ####上面问题的原因可能是使用了过多的 vector，那么就使用迭代器，就可以了，代码如下：\nTreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { \treturn build(preorder.begin(), preorder.end(), inorder.begin(), inorder.end()); } TreeNode *build(vector\u0026lt;int\u0026gt;::iterator preb, vector\u0026lt;int\u0026gt;::iterator pree, vector\u0026lt;int\u0026gt;::iterator inb, vector\u0026lt;int\u0026gt;::iterator ine) { \tif (preb == pree) \t{ \treturn nullptr; \t} \tauto root = new TreeNode(*preb); \tauto itrPos = find(inb,ine, *preb); \tauto size = distance(inb,itrPos); \troot-\u0026gt;left = build(preb + 1, preb + 1 + size, inb, itrPos); \troot-\u0026gt;right = build(preb + 1 + size, pree, itrPos+1, ine); \treturn root; } ","permalink":"http://logeable.github.io/posts/construct-binary-tree-from-preorder-and-inorder-traversal-/","summary":"Given preorder and inorder traversal of a tree, construct the binary tree.\nNote: You may assume that duplicates do not exist in the tree\nhttps://oj.leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\n ####我提交下面代码后，提示 Memory Limit Exceeded\nTreeNode *buildTree(vector\u0026lt;int\u0026gt; \u0026amp;preorder, vector\u0026lt;int\u0026gt; \u0026amp;inorder) { \tif (preorder.size() == 0) \t{ \treturn nullptr; \t}  \tauto root = new TreeNode(preorder[0]); \tauto itrPos = find(inorder.begin(), inorder.end(), preorder[0]); \tvector\u0026lt;int\u0026gt; vlin(inorder.begin(),itrPos),vrin(itrPos+1,inorder.end()); \tvector\u0026lt;int\u0026gt; vlpre(preorder.begin() + 1, preorder.","title":"Construct Binary Tree from Preorder and Inorder Traversal"},{"content":"Say you have an array for which the ith element is the price of a given stock on day i.\nIf you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\nhttps://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/\n ####这一题容易出错的地方是这样求解，求出最大和最小值，然后相减，但是这一题最小值必须在最大值前面，因为不可能在最贵的时候买入，在最便宜的是活卖出。\nint maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { \tif (prices.size() == 0) \t{ \treturn 0; \t} \tint max, min; \tmax = min = prices[0]; \tfor (auto m : prices) \t{ \tif (m\u0026gt;max) \t{ \tmax = m; \t} \tif (min\u0026lt;m) \t{ \tmin = m; \t} \t} \treturn max - min; } ####知道这一点后很容易用 O^2 求解\nint maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { \tint max = 0; \tfor (int i = 0; i \u0026lt; prices.size(); i++) \t{ \tfor (int j = i; j \u0026lt; prices.size(); j++) \t{ \tif (prices[j] - prices[i]\u0026gt;max) \t{ \tmax = prices[j] - prices[i]; \t} \t} \t} \treturn max; } ####但是毫无疑问会超时，下面是用贪心算法将复杂度降低至 O(n).\nint maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { \tint max = 0; \tint s, e; \ts = e = 0; \tfor (e = 0; e\u0026lt;prices.size(); e++) \t{ \tint d = prices[e] - prices[s]; \tif (d\u0026lt;0) \t{ \ts = e; \t} \tif (d\u0026gt;max) \t{ \tmax = d; \t} \t} \treturn max; } ","permalink":"http://logeable.github.io/posts/best-time-to-buy-and-sell-stock-/","summary":"Say you have an array for which the ith element is the price of a given stock on day i.\nIf you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.\nhttps://oj.leetcode.com/problems/best-time-to-buy-and-sell-stock/\n ####这一题容易出错的地方是这样求解，求出最大和最小值，然后相减，但是这一题最小值必须在最大值前面，因为不可能在最贵的时候买入，在最便宜的是活卖出。\nint maxProfit(vector\u0026lt;int\u0026gt; \u0026amp;prices) { \tif (prices.size() == 0) \t{ \treturn 0; \t} \tint max, min; \tmax = min = prices[0]; \tfor (auto m : prices) \t{ \tif (m\u0026gt;max) \t{ \tmax = m; \t} \tif (min\u0026lt;m) \t{ \tmin = m; \t} \t} \treturn max - min; } ####知道这一点后很容易用 O^2 求解","title":"Best Time to Buy and Sell Stock"},{"content":"Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  For example, Consider the following matrix:\n[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] https://oj.leetcode.com/problems/search-a-2d-matrix/\n ####本题采用二分搜索。\nclass Solution { public: \tbool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;matrix,int target) \t{ \tint l,r,mid; \tl=0; \tr=matrix.size()-1; \twhile(l\u0026lt;=r) \t{ \tmid=l+(r-l)/2; \tint flag=false; \tfor(auto m:matrix[mid])//判断target是否在当前行 \t{ \tif(m==target) \t{ \treturn true; \t} \t} \tif(!flag) \t{ \tif(target \u0026lt; matrix[mid][0]) \t{ \tr=mid-1; \t} \telse \t{ \tl=mid+1; \t} \t} \t} \treturn false; \t} }; ","permalink":"http://logeable.github.io/posts/search-a-2d-matrix/","summary":"Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\n Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  For example, Consider the following matrix:\n[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] https://oj.leetcode.com/problems/search-a-2d-matrix/","title":"Search a 2D Matrix"},{"content":"Given an array of integers, find two numbers such that they add up to a specific target number.\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution.\nInput: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 https://oj.leetcode.com/problems/two-sum/\n ####这一题很容易用 O(n^2)解出来\nfor(int i=0;i\u0026lt;numbers.size();i++) { \tfor(int j=i+1;j\u0026lt;numbers.size();j++) \t{ \tif(numbers[i]+numbers[j]==target) \t{ \t/*...............*/ \t} \t} } ####但是毫无疑问会超时，选用 map 可以将时间复杂度降低至 O(n).\nclass Solution { public:  vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt; \u0026amp;numbers, int target) {  map\u0026lt;int,int\u0026gt; m;  for(int i=0;i\u0026lt;numbers.size();i++)  {  if(m.find(numbers[i])==m.end())  {  m[target-numbers[i]]=i;  }  else  {  return vector\u0026lt;int\u0026gt;{m[numbers[i]]+1,i+1};  }  }  } }; ","permalink":"http://logeable.github.io/posts/two-sum/","summary":"Given an array of integers, find two numbers such that they add up to a specific target number.\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.\nYou may assume that each input would have exactly one solution.\nInput: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 https://oj.","title":"Two Sum"},{"content":"Given two sorted integer arrays A and B, merge B into A as one sorted array.\nNote: You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.\nhttps://oj.leetcode.com/problems/merge-sorted-array/\n class Solution { public:  void merge(int A[], int m, int B[], int n) {  int i=0,j=0;  int *C=new int[m+n];  while(i\u0026lt;m\u0026amp;\u0026amp;j\u0026lt;n)  {  if(A[i]\u0026lt;B[j])  {  C[i+j]=A[i];  i++;  }  else  {  C[i+j]=B[j];  j++;  }  }  while(i\u0026lt;m)  {  C[i+j]=A[i];  i++;  }  while(j\u0026lt;n)  {  C[i+j]=B[j];  j++;  }  for(i=0;i\u0026lt;m+n;i++)  {  A[i]=C[i];  }  } }; ","permalink":"http://logeable.github.io/posts/merge-sorted-array-/","summary":"Given two sorted integer arrays A and B, merge B into A as one sorted array.\nNote: You may assume that A has enough space (size that is greater or equal to m + n) to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.\nhttps://oj.leetcode.com/problems/merge-sorted-array/\n class Solution { public:  void merge(int A[], int m, int B[], int n) {  int i=0,j=0;  int *C=new int[m+n];  while(i\u0026lt;m\u0026amp;\u0026amp;j\u0026lt;n)  {  if(A[i]\u0026lt;B[j])  {  C[i+j]=A[i];  i++;  }  else  {  C[i+j]=B[j];  j++;  }  }  while(i\u0026lt;m)  {  C[i+j]=A[i];  i++;  }  while(j\u0026lt;n)  {  C[i+j]=B[j];  j++;  }  for(i=0;i\u0026lt;m+n;i++)  {  A[i]=C[i];  }  } }; ","title":"Merge Sorted Array"},{"content":" 在刚开始学习图形编程的时候它是一项令人生畏的任务。渲染管线设计大量的步骤，每一步又处理各种数学运算。stage 为下一个 stage 运行实际的程序来计算结果。熟悉管线，把它当成工具来实现视觉特效，这是成为图形学程序员的本质。 这本书的这一小节介绍一些基础 3D 图形数学，OpenGL 中的管线以及展示数据是怎么流经这些图形管线的。\n  译文：http://www.arcsynthesis.org/gltut/Basics/Introduction.html\n 向量 这本书假设你熟悉代数学和几何学，但是向量数学不是必须的。后面的章节将会学习到更多复杂主题，但是这里仅仅介绍一些向量数学的基础。\n一个向量可以有许多意思，取决于我门市在谈论几何上的还是数字上的。在每一种情形中，向量都有维度；一个二维向量局限于一个平面中，然而一个三维向量可以在任意物理空间中起作用。向量也可以有更高的维度，但是通常我们仅仅处理 2 到 4 维。\n学术上将一个仅有一个维度的向量叫做标量。\n在几何学方面，一个向量能够表示两种概念：在一个特定空间中的位置和方向。一个位置向量表示一个特定空间中的方位。例如，在下面这个图中我们有 3 个位置向量 A B C：\n![VectorDirections]({{ site.baseurl }}/images/OpenGL 基础/VectorPosition.svg)\n一个向量也能表示一个方向。方向向量没有原点；它们仅仅指定一个空间中的方向。下面这幅图中都是方向向量，但是向量 B 和向量 D 是相同的，几十它们呗华仔不同的位置：\n![VectorPosition]({{ site.baseurl }}/images/OpenGL 基础/VectorDirections.svg)\n向量也可以用于数字上的表述。这种向量是一系列的数字，每一个维度都是一个数字。因此一个二维向量有两个数字；一个三维向量有三个数字，以此类推。标量，就仅仅只有一个数字。\n在向量中的每一个数字被叫做一个分量。每一个分量通常有一个名字。对于我们来说，向量的第一个分量是叫做X 分量，第二个分量叫做Y 分量，第三个叫做Z 分量，而且如果有第四个，那么它叫做W 分量。\n当我们用文本来写一个向量时，它们被写在括号中。因此一个三维向量例如(0,2,4)；X 分量是 0，Y 分量是 2，Z 分量是 4.当将它们写在等式中的时候，他们被写成：\n![ColumnVector]({{ site.baseurl }}/images/OpenGL 基础/ColumnVector.svg)\n在数学等式中，向量变量不仅适用粗体而且在变量的上面还有一个箭头。\n当用图形画向量的时候，位置向量和方向向量就有区别了。然而，数字上的向量并没有任何区别。仅有的区别是如何使用而不是如何表示它们。因此你能够将一个位置向量看成是一个方向并且对它们应用一些向量运算，然后又将结果看成是一个位置向量。\n即使向量有独立的数字分量，但是也有许多数学运算能够应用在向量上。我们将使用几何和数字两种方式来展示其中的一部分运算。\n向量加法 图形上的表示如下：\n![VectorAddition]({{ site.baseurl }}/images/OpenGL 基础/VectorAddition.svg)\n记住向量的方向能够被平移但不改变它们的值。因此如果你将两个向量的头尾相连，向量的加法就是从第一个向量的尾部到最后一个向量的头部的方向。\n![VectorAdditionHeads]({{ site.baseurl }}/images/OpenGL 基础/VectorAdditionHeads.svg)\n数字上来说，两个向量的和就是将它们相应的分量加起来：\n![VectorAdditionNum]({{ site.baseurl }}/images/OpenGL 基础/VectorAdditionNum.svg)\n任何作用在向量的每一个分量上的运算被称为分量按位运算(component-wise operation)。向量加法就是一个分量按位运算任何作用在两个向量上的分量按位运算要求两个向量有相同的维度。\n向量取反和减法 图形上的表示如下：\n![VectorNegation]({{ site.baseurl }}/images/OpenGL 基础/VectorNegation.svg)\n数字上来书，这意味着向量的每一个分量都取负数。\n![VectorNegationNum]({{ site.baseurl }}/images/OpenGL 基础/VectorNegationNum.svg)\n就像标量，向量的减法如同将一个向量加上另一个向量的取反。\n![VectorSubtraction]({{ site.baseurl }}/images/OpenGL 基础/VectorSubtraction.svg)\n向量乘法 向量乘法是向量运算中少数没有几何上的等价表示中的一个。将一个方向乘上另一个方向，或者将一个位置乘上另一个位置都没有实际意义。但是那并不是说数字上的等式没有用。\n向量相乘在数字上也是想向量加法一样简单的将分量相乘。\n![VectorMultiplicationNum]({{ site.baseurl }}/images/OpenGL 基础/VectorMultiplicationNum.svg)\n向量能够乘上一个标量意味着伸长或者缩短向量的长度，这取决于标量的值。\n![VectorScalarMult]({{ site.baseurl }}/images/OpenGL 基础/VectorScalarMult.svg)\n数字上来讲，这也是个分量按位乘法，向量中的每一个分量都会乘上这个标量。\n![VectorScalarMultNum]({{ site.baseurl }}/images/OpenGL 基础/VectorScalarMultNum.svg)\n向量也能够加上一个标量。这像是向量乘以向量，是没有几何表示的。它是一个分量按位加法。\n![VectorScalarAddNum]({{ site.baseurl }}/images/OpenGL 基础/VectorScalarAddNum.svg)\n向量代数 了解一些向量运算县官的规则是很有用的。向量加法和乘法遵循许多和标量加法乘法一样的规则。它们是交换律，结合律和分配律。\n![VectorMathProperties]({{ site.baseurl }}/images/OpenGL 基础/VectorMathProperties.svg)\n向量/标量 运算有一些相思的属性。\n长度 向量是有长度的。向量的长度是从向量的起始点到终点的距离。数字上来说，计算向量距离需要这个等式：\n![VectorLengthNum]({{ site.baseurl }}/images/OpenGL 基础/VectorLengthNum.svg)\n这个等式使用毕达哥拉斯定理来计算向量长度。这个等式可以用在任意维度的向量上，而不仅仅是二维或者三维。\n单位向量和正规化 一个长度为一的向量被称为单位向量。单位向量拥有一个单位长度，它用来表示一个方向。在数学表达式中通常在单位向量变量的上面写上^。\n一个向量能够通过正规化被转换成一个单位向量。这是通过将向量除以它的长度完成的，公示如下：\n![VectorNormalizationNum]({{ site.baseurl }}/images/OpenGL 基础/VectorNormalizationNum.svg)\n这不是这写教程中所有的向量数学。新的向量数学运算将在第一次需要实用的时候被介绍和解释。并且它们中的大多数都不是分量按位运算。\n","permalink":"http://logeable.github.io/posts/opengl%E5%9F%BA%E7%A1%80/","summary":"在刚开始学习图形编程的时候它是一项令人生畏的任务。渲染管线设计大量的步骤，每一步又处理各种数学运算。stage 为下一个 stage 运行实际的程序来计算结果。熟悉管线，把它当成工具来实现视觉特效，这是成为图形学程序员的本质。 这本书的这一小节介绍一些基础 3D 图形数学，OpenGL 中的管线以及展示数据是怎么流经这些图形管线的。\n  译文：http://www.arcsynthesis.org/gltut/Basics/Introduction.html\n 向量 这本书假设你熟悉代数学和几何学，但是向量数学不是必须的。后面的章节将会学习到更多复杂主题，但是这里仅仅介绍一些向量数学的基础。\n一个向量可以有许多意思，取决于我门市在谈论几何上的还是数字上的。在每一种情形中，向量都有维度；一个二维向量局限于一个平面中，然而一个三维向量可以在任意物理空间中起作用。向量也可以有更高的维度，但是通常我们仅仅处理 2 到 4 维。\n学术上将一个仅有一个维度的向量叫做标量。\n在几何学方面，一个向量能够表示两种概念：在一个特定空间中的位置和方向。一个位置向量表示一个特定空间中的方位。例如，在下面这个图中我们有 3 个位置向量 A B C：\n![VectorDirections]({{ site.baseurl }}/images/OpenGL 基础/VectorPosition.svg)\n一个向量也能表示一个方向。方向向量没有原点；它们仅仅指定一个空间中的方向。下面这幅图中都是方向向量，但是向量 B 和向量 D 是相同的，几十它们呗华仔不同的位置：\n![VectorPosition]({{ site.baseurl }}/images/OpenGL 基础/VectorDirections.svg)\n向量也可以用于数字上的表述。这种向量是一系列的数字，每一个维度都是一个数字。因此一个二维向量有两个数字；一个三维向量有三个数字，以此类推。标量，就仅仅只有一个数字。\n在向量中的每一个数字被叫做一个分量。每一个分量通常有一个名字。对于我们来说，向量的第一个分量是叫做X 分量，第二个分量叫做Y 分量，第三个叫做Z 分量，而且如果有第四个，那么它叫做W 分量。\n当我们用文本来写一个向量时，它们被写在括号中。因此一个三维向量例如(0,2,4)；X 分量是 0，Y 分量是 2，Z 分量是 4.当将它们写在等式中的时候，他们被写成：\n![ColumnVector]({{ site.baseurl }}/images/OpenGL 基础/ColumnVector.svg)\n在数学等式中，向量变量不仅适用粗体而且在变量的上面还有一个箭头。\n当用图形画向量的时候，位置向量和方向向量就有区别了。然而，数字上的向量并没有任何区别。仅有的区别是如何使用而不是如何表示它们。因此你能够将一个位置向量看成是一个方向并且对它们应用一些向量运算，然后又将结果看成是一个位置向量。\n即使向量有独立的数字分量，但是也有许多数学运算能够应用在向量上。我们将使用几何和数字两种方式来展示其中的一部分运算。\n向量加法 图形上的表示如下：\n![VectorAddition]({{ site.baseurl }}/images/OpenGL 基础/VectorAddition.svg)\n记住向量的方向能够被平移但不改变它们的值。因此如果你将两个向量的头尾相连，向量的加法就是从第一个向量的尾部到最后一个向量的头部的方向。\n![VectorAdditionHeads]({{ site.baseurl }}/images/OpenGL 基础/VectorAdditionHeads.","title":"OpenGL基础"}]